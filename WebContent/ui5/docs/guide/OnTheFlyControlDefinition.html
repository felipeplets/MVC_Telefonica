<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  
  

  


  

  <head>
    <title>
      Documentation/AdvancedTopics/OnTheFlyControlDefinition â€“ SAPUI5 Wiki (TIP CORE User Interface)
    </title>
        
        
        
        
        <link rel="stylesheet" href="redirect.css" type="text/css" />
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
        <link rel="icon" href="favicon.ico" type="image/x-icon" />
      
    
    
    
    
    <script src="../../resources/sap/ui/thirdparty/jquery/jquery-1.7.1.js"></script>
    <script src="../../js/utils.js"></script>
    <link rel="stylesheet" type="text/css" href="../../theme/dev-guide.css" />
  </head>
  <body>
    
    
    
    <div id="content" class="wiki">
      
      <div class="wikipage searchable">
        
          <p>
</p><p>
</p>
<h1 id="HowtoDevelopUI5ControlsWithinJavaScript">How to Develop UI5 Controls Within JavaScript</h1>
<h2 id="Overview">Overview</h2>
<p>
This page explains how to create new Controls in JavaScript on the fly (so-called "Notepad Controls"). For this basic development approach, it is not necessary to define libraries or to run generation steps. It is possible to extend existing Controls and to create completely new Controls. 
</p>
<p>
Technically, this functionality is not restricted to Controls. Arbitrary objects derived from sap.ui.base.Object can be created or extended.
</p>
<h2 id="WhentousethisinsteadofEclipse-basedControlDevelopment">When to use this instead of Eclipse-based Control Development?</h2>
<p>
Technically, the resulting Controls are equal to Controls developed using the UI5 Eclipse tools, so when to use which approach?
</p>
<p>
These on-the-fly Controls described here have the advantage of being created very quickly without any tooling or build or dependency overhead, e.g. just inline in the middle of the application. All JavaScript can be just in one file, the application CSS, which may anyway be present, can contain the required styles. So it is a very light-weight approach, but still offering all the features of a real UI5 Control.<br />
A weakness is that the Control cannot be re-used easily from very different places and applications: there is no formal way to address it, there is no package which you can reference to import the control. Also, if the control should support multiple themes and should be styled using UI5 theme parameters which are editable in the Theme Editor, if the right-to-left version of the styles should be generated automatically, the Eclipse-based tools offer everything with their integrated build. Checks are not run on a on-the-fly Control, no JSDoc documentation can be created.
</p>
<p>
So the general rule of thumb is that if a Control is supposed to be re-used in different applications or by people who do not closely communicate with the Control developer and if it is going to be a bit more complex than a very basic Control, one should increasingly consider formally creating a Control Library and using the UI5 Eclipse to do so.
</p>
<h2 id="BasicConcept:ExtendMethod">Basic Concept: Extend Method</h2>
<p>
The <tt>extend()</tt> method is available on all Controls (and the base classes) and is used to define a new subclass. The following code would create a new Control from scratch:
</p>
<pre class="wiki">sap.ui.core.Control.extend(...);
</pre><p>
The following code would create a new Control which inherits from Button:
</p>
<pre class="wiki">sap.ui.commons.Button.extend(...);
</pre><p>
The parameters to this function are the <strong>name</strong> and the <strong>definition</strong> of the new Control type. The definition part contains information about the Control API this means which properties, aggregations, events etc. it has and the implementation of the Control methods. Additionally, it provides the function that creates the Control's HTML structure.
</p>
<p>
Note that some methods such as the getters and setters for the properties and aggregations or the methods for attaching/detaching event handlers, for example, are automatically created by UI5. Indeed, you can develop a non-default implementation that provides more or other functionality.
</p>
<h2 id="AFirstBasicExample">A First Basic Example</h2>
<p>
The following code creates a simple Control which has a <tt>name</tt> property and which has the purpose to render the text "Hello &lt;name&gt;":
</p>
<div class="code"><pre>sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">Control</span><span class="o">.</span><span class="na">extend</span><span class="o">(</span><span class="s">"my.Hello"</span><span class="o">,</span> <span class="o">{</span>      <span class="c1">// call the new Control type "my.Hello" 
</span>                                              <span class="c1">// and let it inherit from sap.ui.core.Control
</span>    metadata <span class="o">:</span> <span class="o">{</span>                              <span class="c1">// the Control API
</span>        properties <span class="o">:</span> <span class="o">{</span>
            <span class="s">"name"</span> <span class="o">:</span> <span class="s">"string"</span>                 <span class="c1">// setter and getter are created behind the scenes, 
</span>                                              <span class="c1">// including data binding and type validation
</span>        <span class="o">}</span>
    <span class="o">},</span>

    renderer <span class="o">:</span> function<span class="o">(</span>oRm<span class="o">,</span> oControl<span class="o">)</span> <span class="o">{</span>      <span class="c1">// the part creating the HTML
</span>        oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;span&gt;Hello "</span><span class="o">);</span>
        oRm<span class="o">.</span><span class="na">writeEscaped</span><span class="o">(</span>oControl<span class="o">.</span><span class="na">getName</span><span class="o">());</span> <span class="c1">// write the Control property 'name', with XSS protection
</span>        oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;/span&gt;"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</pre></div><p>
The new Control is ready for use now. It can be instantiated and displayed as usual:
</p>
<div class="code"><pre><span class="k">new</span> my<span class="o">.</span><span class="na">Hello</span><span class="o">({</span><span class="nl">name:</span><span class="s">"UI5"</span><span class="o">}).</span><span class="na">placeAt</span><span class="o">(</span><span class="s">"content"</span><span class="o">);</span>
</pre></div><p>
We will focus on some more realistic examples lateron; before, let's have a glance at some further basic concepts.
</p>
<h2 id="FurtherTechnicalBackground">Further Technical Background</h2>
<h3 id="WhatisaControl">What is a Control?</h3>
<ul><li>A Control is an object that defines the <strong>appearance</strong> and <strong>behavior</strong> of a screen area.
</li><li>A Control typically has <strong>properties</strong> like "text" or "width" that modify the appearance or relate to the data displayed by the Control.
</li><li>It can <strong>aggregate</strong> other Controls. This means it is a sort of <i>container</i> or <i>layout</i> Control where the application can add the child controls to use - or a <i>composite</i> Control if the Control itself decides what the child Controls are and just re-uses these available components. Child controls in an aggregation are real children and owned by the parent control; they are destroyed when the parent control is destroyed and any Control can only have <i>one</i> aggregation parent. Adding it to a different aggregation will remove it from the previous parent.
</li><li>It can also have <strong>associated</strong> Controls that are not part or children of this Control, but rather loosely related. In an association Controls are connected by ID rather than by reference. Destroying one Control in an association does not affect the other one. It can happen that a Control which is referenced in an association by its ID does not exist yet or anymore. 
</li><li>A Control can fire well-defined <strong>events</strong>. Typically, these have a meaning that relates to the Control's purpose and functionality and is on a semantically higher level than "click" or other browser events. Examples would be <tt>triggerSearch</tt> in a SearchField or <tt>collapse</tt> in a Panel.
</li></ul><p>
All this information is defined in the Control meta data which on the one hand is the public API of the Control (and can be queried at runtime) and on the other hand contains useful information for runtime features like data binding and type validation checks.
</p>
<h3 id="ControlBaseClasses">Control Base Classes</h3>
<p>
<strong><tt>sap.ui.core.Control</tt></strong> is the base class of all UI5 Controls. Specific Controls can either inherit from this base class or from another Control, in order to inherit and extend its functionality. <strong><tt>sap.ui.core.Element</tt></strong> is the base class of <tt>sap.ui.core.Control</tt>. Elements can be like parts of Controls or rather configuration packages for parts of Controls, but in general they are NOT meant for standalone use and they do not have their own renderer. The Controls that use these elements do the rendering (for example a ListItem Element is rendered by the ListBox Control). Whatever this page documents about Controls, it usually also applies to Elements (but not to the renderer).
</p>
<h3 id="ControlName">Control Name</h3>
<p>
The Control name is a string that consists of Library name and Control name. For both names, you use letters and dots for separation where you should avoid dublicates regarding other JS entity namings within the same application. It is also possible that you omit the library name and call the Control <tt>Square</tt>. You would generally do this if you there is no need for assigning the control to a library which shall also be available 
for developing other applications. When you write a Control to be reused by others, a unique Library name is recommended: <tt>sap.byd.Square</tt>.
</p>
<h3 id="ControlMetadata">Control Metadata</h3>
<p>
For the creation of new Controls, the metadata block defines the properties, aggregations, events etc. of the Control. Depending on the Control, not only the number of entries, but also their amount of information can be small or quite extensive.
</p>
<p>
For the use case class extension - where the classes do not inherit from Control or Element but from a more generic class - these Control-specific settings are not available. For more information, read chapter "Object Metadata and Implementation" below. Note that all the object metadata described there is also applicable for extending Controls.
</p>
<h4 id="Properties">Properties</h4>
<p>
A property is defined by at least its name and its type. Additionally, the default value of the property can be defined. So the available settings are:
</p>
<ul><li><tt>type</tt>: The data type of the Control property. Automatic type validation is done in the UI5 core. Examples for valid types are:
<ul><li><tt>string</tt> for a string property (default)
</li><li><tt>int</tt> or <tt>float</tt> for number properties
</li><li><tt>int[]</tt> etc. for arrays
</li><li><tt>sap.ui.core.CSSSize</tt> for a custom-defined type
</li></ul></li><li><tt>defaultValue</tt>: The default value this property should have when the application does not set a value. If no default value is given, the property initially has value <tt>undefined</tt>.
</li></ul><p>
So property definitions can look like this:
</p>
<div class="code"><pre><span class="nl">properties:</span> <span class="o">{</span>
   <span class="s">"title"</span> <span class="o">:</span> <span class="s">"string"</span><span class="o">,</span>                         <span class="c1">// a simple string property, default value is {{{undefined}}}
</span>   <span class="s">"buttonText"</span> <span class="o">:</span> <span class="o">{</span><span class="nl">defaultValue:</span> <span class="s">"Search"</span><span class="o">},</span>    <span class="c1">// when no type is given, the type is {{{string}}}
</span>   <span class="s">"showLogoutButton"</span> <span class="o">:</span> <span class="o">{</span>type <span class="o">:</span> <span class="s">"boolean"</span><span class="o">,</span> defaultValue <span class="o">:</span> <span class="kc">true</span><span class="o">},</span>   <span class="c1">// a boolean property where a default value is given
</span>   <span class="s">"width"</span> <span class="o">:</span> <span class="o">{</span>type <span class="o">:</span> <span class="s">"sap.ui.core.CSSSize"</span><span class="o">,</span> defaultValue <span class="o">:</span> <span class="s">"50px"</span><span class="o">}</span> <span class="c1">// a CSS size property where a default value is given
</span><span class="o">}</span>
</pre></div><p>
From the technical point of view, you could also define the "group" (the category into which this property falls), but this has no impact outside of development tools which may want to display and group the properties of your Control.
</p>
<p>
Once such a property is defined, the Control automatically has the methods <tt>setShowLogoutButton</tt> and <tt>getShowLogoutButton</tt> which are responsible for storing the data. You can give your own custom definition for either of them, you have to call the generic property setter/getter <tt>setProperty</tt>/<tt>getProperty</tt> then.
</p>
<h4 id="Events">Events</h4>
<p>
Events are specified by the event name only. In many cases there is nothing to configure about them, so just give an empty object:
</p>
<div class="code"><pre><span class="nl">events:</span> <span class="o">{</span>
   <span class="s">"logout"</span><span class="o">:</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div><p>
As an advanced feature, Controls can enable events to be interrupted by the application, when usually the Control would immediately execute an action. For example, if a Tab Control fires a "close" event and wants to enable the application to cancel the closing. To do so, the Control needs to set the <tt>allowPreventDefault</tt> property of the Event to "true" (and check the return value after firing the event):
</p>
<div class="code"><pre><span class="nl">events:</span> <span class="o">{</span>
   <span class="s">"close"</span><span class="o">:</span> <span class="o">{</span>allowPreventDefault <span class="o">:</span> <span class="kc">true</span><span class="o">}</span>  
<span class="o">}</span>
</pre></div><p>
For every defined Event, methods for registering, de-registering and firing the event are created, in this case: <tt>attachLogout</tt>, <tt>detachLogout</tt>, <tt>fireLogout</tt>
</p>
<h4 id="AggregationsAssociations">Aggregations/Associations</h4>
<p>
Aggregations and associations (find the explanation of the difference between them above) are again defined by their name, along with an object that can have the following information:
</p>
<ul><li><tt>type</tt>: This should be a type which is subclass of Element or Control (default is <tt>sap.ui.core.Control</tt>)
</li><li><tt>multiple</tt>: Whether it is a 0..1 aggregation or a 0..n aggregation (default is "true", which means 0..n, for aggregations and "false" for associations)
</li><li><tt>singularName</tt>: For 0..n aggregations, the aggregation name typically is plural, but certain methods are created where the singular form is required (for example, <tt>addWorksetItem</tt>} for the "worksetItem<strong>s</strong>" aggregation).
</li><li><tt>visibility</tt>: The visibility of this aggregation (default is "public"). See further details below in section "Hidden Aggregations"
</li></ul><p>
<br />
If only the type needs to be set, you can just give it as a string instead of the configuration object.
</p>
<p>
One example:
</p>
<div class="code"><pre><span class="nl">aggregations:</span> <span class="o">{</span>
   <span class="s">"acceptButton"</span> <span class="o">:</span> <span class="s">"sap.ui.commons.Button"</span><span class="o">,</span> <span class="c1">// if only type is given, no object is required
</span>   <span class="s">"content"</span> <span class="o">:</span> <span class="o">{</span><span class="nl">singularName:</span> <span class="s">"content"</span><span class="o">},</span>    <span class="c1">// default type is "sap.ui.core.Control", 
</span>                                             <span class="c1">// which is appropriate for generic containers
</span>   <span class="s">"worksetItems"</span> <span class="o">:</span> <span class="o">{</span>type <span class="o">:</span> <span class="s">"sap.ui.ux3.NavigationItem"</span><span class="o">,</span> multiple <span class="o">:</span> <span class="kc">true</span><span class="o">,</span> singularName <span class="o">:</span> <span class="s">"worksetItem"</span><span class="o">}</span> 
                                             <span class="c1">// a fully specified aggregation
</span><span class="o">}</span>
</pre></div><p>
Multiple methods are created, depending on the multiplicity, for example: <tt>getWorksetItems</tt>, <tt>insertWorksetItem</tt>, <tt>addWorksetItem</tt>, <tt>removeWorksetItem</tt>, <tt>removeAllWorksetItems</tt>, <tt>indexOfWorksetItem</tt>, <tt>destroyWorksetItems</tt>
</p>
<p>
When you want to mark one aggregation as default aggregation (in order to be able to omit the aggregation tag in XMLViews), you can do it by setting the defaultAggregation property to the name of the aggregation like this:
</p>
<div class="code"><pre><span class="nl">aggregations:</span> <span class="o">{</span>
   <span class="s">"content"</span><span class="o">:</span> <span class="o">{</span><span class="nl">singularName:</span> <span class="s">"content"</span><span class="o">}</span> <span class="c1">// default type is "sap.ui.core.Control", multiple is "true"          
</span><span class="o">},</span>
<span class="nl">defaultAggregation:</span> <span class="s">"content"</span>
</pre></div><h4 id="Methods">Methods</h4>
<p>
You can add any method to a new Control by providing the implementation, without adding it to the metadata. By convention, all methods are public, exception here is if their name starts with an underscore, or if it is one of the special method types listed below.
Other Controls and the application may only call public methods and the Control needs to ensure they remain compatible. Though, there are no technical rules that prevent a call of private methods. 
Public methods are the generated getter/setter methods for properties etc. .
</p>
<h3 id="TheControlImplementation">The Control Implementation</h3>
<p>
After the metadata is defined, you can add any method implementations to your new Control. In general, the method names can be chosen freely, but note that some method names must be avoided:
</p>
<ul><li>Names of methods that are provided by a super class (or will be provided&hellip;). Your implementation overwrites their's, that's the deal with inheritance.
</li><li>set&hellip;/get&hellip;/insert&hellip;/add&hellip;/remove&hellip;/indexOf&hellip; may collide with setters/getters for properties or aggregations you defined
</li><li>attach&hellip;/detach&hellip;/fire may collide with methods created for events
</li></ul><p>
As long as you do not introduce the respective property or so, you are of course safe to use a certain "set&hellip;" method name.
</p>
<p>
There are some method names you may use but which have a special meaning:
</p>
<ul><li><tt>on...</tt>: Methods starting with "on" are event handlers that are automatically bound to browser events
</li><li><tt>init</tt>: Is the name of the initialization function called right after Control instantiation
</li><li><tt>renderer</tt>: Is a special name that holds either 
<ul><li>the function that creates the Control's HTML or 
</li><li>a complete structure that contains this function and more (for more information see below)
</li></ul></li></ul><h4 id="NormalMethods">Normal Methods</h4>
<p>
Any method, either public or private, is just appended to the implementation object. The convention is that private methods that may not be called from outside a Control start with an underscore. All other methods are considered public as long as they do not belong to the special method types listed below.
</p>
<div class="code"><pre>   <span class="nl">divide:</span> function<span class="o">(</span>x<span class="o">,</span> y<span class="o">)</span> <span class="o">{</span>     <span class="c1">// a public method of the Control
</span>      <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">_checkForZero</span><span class="o">(</span>y<span class="o">))</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">"Second parameter may not be zero"</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> x <span class="o">/</span> y<span class="o">;</span>
   <span class="o">},</span>

   <span class="nl">_checkForZero:</span> function<span class="o">(</span>y<span class="o">)</span> <span class="o">{</span> <span class="c1">// private helper method
</span>      <span class="k">if</span> <span class="o">(</span>y <span class="o">===</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
   <span class="o">}</span>
</pre></div><h4 id="initMethod"><tt>init()</tt> Method</h4>
<p>
The <tt>init()</tt> method is invoked by the UI5 core for each Control instance right after the constructor. Use this to set up things like internal variables or sub-Controls of a composite. Note that any values given in the Control constructor are NOT yet available! This is intentional to prevent the typical error where Controls would only work fine when values are set initially, but not when values are changed later. This method is considered private and only to be called by the UI5 core.
</p>
<p>
If you inherit from another control that has (or might get) an <tt>init()</tt> method, you need to explicitly call it, otherwise it will not be executed, which may leave the superclass not properly initialized.
</p>
<div class="code"><pre>   <span class="nl">init:</span> function<span class="o">()</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">_bSearchHasBeenTriggered</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">_oSearchButton</span> <span class="o">=</span> <span class="k">new</span> sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">Button</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">"-searchBtn"</span><span class="o">,</span> <span class="o">{</span><span class="nl">text:</span> <span class="s">"Search"</span><span class="o">});</span>
   <span class="o">}</span>
</pre></div><p>
And with <tt>init()</tt> call of the superclass, assuming the custom control inherits from DatePicker:
</p>
<div class="code"><pre>  <span class="nl">init:</span> function<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">DatePicker</span><span class="o">.</span><span class="na">prototype</span><span class="o">.</span><span class="na">init</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// check whether superclass has an init() method
</span>      sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">DatePicker</span><span class="o">.</span><span class="na">prototype</span><span class="o">.</span><span class="na">init</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> arguments<span class="o">);</span>  <span class="c1">// call super.init()
</span>    <span class="o">}</span>
    <span class="c1">// ...continue initialization...
</span>  <span class="o">}</span>
</pre></div><h4 id="EventHandlerMethods">Event Handler Methods</h4>
<p>
Methods that have a name starting with "on" are reserved for event handlers. For common events such as "click" or "keydown", browser event handlers for these methods are registered automatically by the UI5 core. So it is sufficient to simple add a handler method, and it will automatically be called. Additionally, the UI5 core fires events with a richer semantic meaning, so Control developers do not need to check so many keycodes etc. The name of these events starts with "sap", they are defined in <tt>jquery.sap.events.js</tt>. One example for such an event is <tt>sapnext</tt> which is triggered by "arrow down" or "arrow right" (or "arrow left" in right-to-left mode). Therefore, multiple checks would be required to check whether the user wants to navigate to the next item. The <tt>sapnext</tt> event takes over all these checks. The "evt" object given to the handler method contains more information. These methods are considered to be private and may only be called by the UI5 core.
</p>
<div class="code"><pre>  <span class="nl">onclick:</span> function<span class="o">(</span>evt<span class="o">)</span> <span class="o">{</span>
     alert<span class="o">(</span><span class="s">"Control "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">" was clicked."</span><span class="o">);</span>
  <span class="o">},</span>

  <span class="nl">onsapnext:</span> function<span class="o">(</span>evt<span class="o">)</span> <span class="o">{</span>
     <span class="c1">// navigate to next item, an arrow key was pressed
</span>     <span class="o">...</span>
  <span class="o">}</span>
</pre></div><h4 id="TheRendererMethodObject">The Renderer Method/Object</h4>
<p>
This method is responsible for creating the HTML structure that makes up the Control. It is different from the other methods, as it is a static one, so the "this" keyword is not available. Instead, a Control instance and a RenderManager instance are given to the method. The RenderManager is used as a sort of "writer" - it is a collector for string fragments and takes care of efficiently concatenating them and placing them into the appropriate DOM position.
</p>
<div class="code"><pre><span class="nl">renderer:</span> function<span class="o">(</span>oRenderManager<span class="o">,</span> oControl<span class="o">)</span> <span class="o">{</span>
   oRenderManager<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;div&gt;"</span><span class="o">,</span> oControl<span class="o">.</span><span class="na">getText</span><span class="o">(),</span> <span class="s">"&lt;/div&gt;"</span><span class="o">);</span>
<span class="o">}</span>
</pre></div><p>
All the features and rules of writing the Control Renderer in normal Control development apply here as well. E.g. the Control must have only ONE HTML element as root node and inside this node <tt>oRenderManager.writeControlData(oControl);</tt> must be called, so this root element can be marked as UI5 control root and the ID of the Control will be written.
</p>
<p>
The newly created renderer type will inherit from the renderer of the parent Control. So if your new Control extends TextField, the given function will be added to a class that inherits from <tt>sap.ui.commons.TextFieldRenderer</tt> (and will have access to that one's other functions). However, your renderer method will override the parent renderer method, so no HTML will be written as long as your method is not taking care of it.
</p>
<p>
If an existing renderer should be used without modification, you can give the name of this renderer class:
</p>
<div class="code"><pre><span class="nl">renderer:</span> <span class="s">"sap.ui.commons.ButtonRenderer"</span>
</pre></div><p>
However, a normal Control Renderer can also override or implement methods from its Renderer superclass. Or just separate out some helper functions.<br />
This is possible as well here, but in this case these methods need to be packed together into an object, so the <tt>extend</tt> method knows they should all go into the Control Renderer. The main rendering method is called "render" - just like in a normal Control Renderer. The keyword "this" actually refers to the Control Renderer type here, so it is used to access the other methods:
</p>
<div class="code"><pre><span class="nl">renderer:</span> <span class="o">{</span>
   <span class="nl">render:</span> function<span class="o">(</span>rm<span class="o">,</span> oControl<span class="o">)</span> <span class="o">{</span>
      rm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;div&gt;"</span><span class="o">);</span>
      rm<span class="o">.</span><span class="na">writeEscaped</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">square</span><span class="o">(</span>oControl<span class="o">.</span><span class="na">getValue</span><span class="o">()));</span>
      rm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;/div&gt;"</span><span class="o">);</span>
   <span class="o">},</span>
   <span class="nl">square:</span> function<span class="o">(</span>value<span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> value <span class="o">*</span> value<span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div><h4 id="HiddenAggregations">Hidden Aggregations</h4>
<p>
Hidden Aggregations are aggregations for which the metadata property <tt>visibility</tt> is set to <tt>hidden</tt> (in contrast to public aggregations which are the default).<br /><br />
Aggregations are used to define a parent-child relationship between a parent control and its children (controls or elements). The knowledge about this relationship is for example relevant for the SAPUI5 Core to dispactch events properly or to cleanup the children when the parent is destroyed.<br /><br />
The purpose of hidden aggregations is to support the development of composite controls. Composite controls internally reuse already existing controls and combine those controls to something new (e.g. a SearchField control which internally uses a TextField and a Button). These inner controls are not intended to be accessed directly from the user of the composite control, so these controls should not be contained within a normal public aggregation. In this case a hidden aggregation can be defined to register the child controls within the control hierarchy without make them public available. You can find more information about composite controls <a class="wiki" href="CompositeControl.html">here</a>.<br /><br />
Because hidden aggregations are only used internally within a composite control for hidden aggregations no typed accessor functions are generated, they are not cloned and databinding is not enabled.
<br /><br />
<strong>Example:</strong>'
</p>
<div class="code"><pre>sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">Control</span><span class="o">.</span><span class="na">extend</span><span class="o">(</span><span class="s">"my.SearchField"</span><span class="o">,</span> <span class="o">{</span>
    metadata <span class="o">:</span> <span class="o">{</span>
        properties <span class="o">:</span> <span class="o">{</span>
            <span class="s">"value"</span> <span class="o">:</span> <span class="s">"string"</span>
        <span class="o">},</span>
        <span class="nl">aggregations:</span> <span class="o">{</span>
            <span class="s">"_tf"</span> <span class="o">:</span> <span class="o">{</span>type <span class="o">:</span> <span class="s">"sap.ui.commons.TextField"</span><span class="o">,</span> multiple <span class="o">:</span> <span class="kc">false</span><span class="o">,</span> <span class="nl">visibility:</span> <span class="s">"hidden"</span><span class="o">},</span>
            <span class="s">"_btn"</span> <span class="o">:</span> <span class="o">{</span>type <span class="o">:</span> <span class="s">"sap.ui.commons.Button"</span><span class="o">,</span> multiple <span class="o">:</span> <span class="kc">false</span><span class="o">,</span> <span class="nl">visibility:</span> <span class="s">"hidden"</span><span class="o">}</span>
        <span class="o">},</span>

        <span class="nl">events:</span> <span class="o">{</span>
            <span class="s">"search"</span> <span class="o">:</span> <span class="o">{}</span>
        <span class="o">}</span>
    <span class="o">},</span>

    <span class="nl">init:</span> function<span class="o">()</span> <span class="o">{</span>
        var that <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">setAggregation</span><span class="o">(</span><span class="s">"_tf"</span><span class="o">,</span> <span class="k">new</span> sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">TextField</span><span class="o">({</span>
          <span class="nl">change:</span> function<span class="o">(</span>oEvent<span class="o">){</span>
            that<span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"value"</span><span class="o">,</span> oEvent<span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"newValue"</span><span class="o">),</span> <span class="kc">true</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">}));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">setAggregation</span><span class="o">(</span><span class="s">"_btn"</span><span class="o">,</span> <span class="k">new</span> sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">Button</span><span class="o">({</span>
          <span class="nl">text:</span> <span class="s">"Search"</span><span class="o">,</span>
          <span class="nl">press:</span> function<span class="o">(){</span>
            that<span class="o">.</span><span class="na">fireSearch</span><span class="o">();</span>
          <span class="o">}</span>
        <span class="o">}));</span>
    <span class="o">},</span>

    <span class="nl">setValue:</span> function<span class="o">(</span>sValue<span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"value"</span><span class="o">,</span> sValue<span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">getAggregation</span><span class="o">(</span><span class="s">"_tf"</span><span class="o">).</span><span class="na">setValue</span><span class="o">(</span>sValue<span class="o">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">},</span>
    
    renderer <span class="o">:</span> function<span class="o">(</span>oRm<span class="o">,</span> oControl<span class="o">)</span> <span class="o">{</span>
        oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;div"</span><span class="o">);</span> 
        oRm<span class="o">.</span><span class="na">writeControlData</span><span class="o">(</span>oControl<span class="o">);</span>
        oRm<span class="o">.</span><span class="na">addClass</span><span class="o">(</span><span class="s">"mySearchField"</span><span class="o">);</span> 
        oRm<span class="o">.</span><span class="na">writeClasses</span><span class="o">();</span>
        oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>
        oRm<span class="o">.</span><span class="na">renderControl</span><span class="o">(</span>oControl<span class="o">.</span><span class="na">getAggregation</span><span class="o">(</span><span class="s">"_tf"</span><span class="o">));</span>
        oRm<span class="o">.</span><span class="na">renderControl</span><span class="o">(</span>oControl<span class="o">.</span><span class="na">getAggregation</span><span class="o">(</span><span class="s">"_btn"</span><span class="o">));</span>
        oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;/div&gt;"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</pre></div><p>
<br />
</p>
<h3 id="ObjectMetadataandImplementation">Object Metadata and Implementation</h3>
<p>
For extending plain objects that are not Elements or Controls, only the following metadata is available (it is <i>also</i> available for extending Controls, though!):
</p>
<ul><li>"interfaces": an optional array of strings that denotes the implemented interfaces
</li><li>"publicMethods": an optional list of methods that should be part of the public API. By default all methods that do not start with an underscore are public.
</li><li>"abstract": an optional flag to mark the type as abstract
</li><li>"final": an optional flag to mark the type as final
</li></ul><p>
 
Regarding the implementation, all methods given outside the metadata are attached to the new type. There is one reserved method name: "constructor". The function given under this name will be the constructor of the new class. While technically you can also define a Constructor for new Elements and Controls, you should <strong>not</strong> do it. Your Control may otherwise break in certain scenarios like with list bindings, or may break later when UI5 extends the constructor signature.
</p>
<p>
<br />
</p>
<h2 id="ExamplesforCreatingNewControls">Examples for Creating New Controls</h2>
<p>
For creating an entirely new Control type, you extend the <tt>sap.ui.core.Control</tt> class. You define the Control API and the implementation from scratch.
</p>
<h3 id="ASimpleSquareControl">A Simple "Square" Control</h3>
<p>
A "Square" Control that is rendered as a red square (surprise!) and has some text written inside and pops up an alert when clicked, looks like this:
</p>
<h4 id="ControlImplementation">Control Implementation</h4>
<div class="code"><pre>  sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">Control</span><span class="o">.</span><span class="na">extend</span><span class="o">(</span><span class="s">"Square"</span><span class="o">,</span> <span class="o">{</span> <span class="c1">// call the new Control type "Square" and let it inherit
</span>                                         <span class="c1">// from sap.ui.core.Control
</span>      
      <span class="c1">// the Control API:
</span>      metadata <span class="o">:</span> <span class="o">{</span>
          properties <span class="o">:</span> <span class="o">{</span>           <span class="c1">// setter and getter are created behind the scenes, 
</span>                                   <span class="c1">// incl. data binding and type validation
</span>              <span class="s">"text"</span> <span class="o">:</span> <span class="s">"string"</span><span class="o">,</span>   <span class="c1">// in simple cases, just define the type
</span>              <span class="s">"size"</span> <span class="o">:</span> <span class="o">{</span><span class="nl">type:</span> <span class="s">"sap.ui.core.CSSSize"</span><span class="o">,</span> <span class="nl">defaultValue:</span> <span class="s">"200px"</span><span class="o">}</span> 
                                   <span class="c1">// you can also give a default value and more
</span>          <span class="o">}</span>
      <span class="o">},</span>
      
      <span class="c1">// the part creating the HTML:
</span>      renderer <span class="o">:</span> function<span class="o">(</span>oRm<span class="o">,</span> oControl<span class="o">)</span> <span class="o">{</span> <span class="c1">// static function, so use the given "oControl" instance 
</span>                                           <span class="c1">// instead of "this" in the renderer function
</span>          oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;div"</span><span class="o">);</span> 
          oRm<span class="o">.</span><span class="na">writeControlData</span><span class="o">(</span>oControl<span class="o">);</span>  <span class="c1">// writes the Control ID and enables event handling - important!
</span>          oRm<span class="o">.</span><span class="na">addStyle</span><span class="o">(</span><span class="s">"width"</span><span class="o">,</span> oControl<span class="o">.</span><span class="na">getSize</span><span class="o">());</span>  <span class="c1">// write the Control property size; the Control has validated it 
</span>                                                      <span class="c1">// to be a CSS size
</span>          oRm<span class="o">.</span><span class="na">addStyle</span><span class="o">(</span><span class="s">"height"</span><span class="o">,</span> oControl<span class="o">.</span><span class="na">getSize</span><span class="o">());</span>
          oRm<span class="o">.</span><span class="na">writeStyles</span><span class="o">();</span>
          oRm<span class="o">.</span><span class="na">addClass</span><span class="o">(</span><span class="s">"mySquare"</span><span class="o">);</span>        <span class="c1">// add a CSS class for styles common to all Control instances
</span>          oRm<span class="o">.</span><span class="na">writeClasses</span><span class="o">();</span>              <span class="c1">// this call writes the above class plus enables support 
</span>                                           <span class="c1">// for Square.addStyleClass(...)
</span>          oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>
          oRm<span class="o">.</span><span class="na">writeEscaped</span><span class="o">(</span>oControl<span class="o">.</span><span class="na">getText</span><span class="o">());</span> <span class="c1">// write another Control property, with protection 
</span>                                                <span class="c1">// against cross-site-scripting
</span>          oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;/div&gt;"</span><span class="o">);</span>
      <span class="o">},</span>
      
      <span class="c1">// an event handler:
</span>      onclick <span class="o">:</span> function<span class="o">(</span>evt<span class="o">)</span> <span class="o">{</span>   <span class="c1">// is called when the Control's area is clicked - no event registration required
</span>          alert<span class="o">(</span><span class="s">"Control clicked! Text of the Control is:\n"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
      <span class="o">}</span>
  <span class="o">});</span>
</pre></div><p>
The Control definition and implementation is finished now, but some styling remains to be done.<br />
The visual appearance could have been written to the Control HTML in the renderer method, just like the instance-specific width and height was written. But it is better to define style that is common to all Control instances in a CSS file, or at least in a &lt;style&gt; tag, so it only needs to be written once and it can be easily modified by the application.<br />
So we add a grey background, a red border and some alignment stuff:
</p>
<div class="code"><pre><span class="o">&lt;</span><span class="nt">style</span><span class="o">&gt;</span>
    <span class="nc">.mySquare</span> <span class="p">{</span>                  <span class="c">/* style the CSS class that has been written by the renderer method */</span>
        <span class="k">display</span><span class="o">:</span> <span class="k">inline</span><span class="o">-</span><span class="k">block</span><span class="p">;</span>   <span class="c">/* enable squares to appear next to each other within one line */</span>
        <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="nb">red</span><span class="p">;</span>   <span class="c">/* add some border, so the square can actually be seen */</span>
        <span class="k">background-color</span><span class="o">:</span> <span class="m">#ddd</span><span class="p">;</span>
        <span class="k">padding</span><span class="o">:</span> <span class="m">8px</span><span class="p">;</span>
        <span class="k">text-align</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span>
        <span class="o">-</span>moz<span class="o">-</span>box<span class="o">-</span>sizing<span class="o">:</span> <span class="k">border</span><span class="o">-</span>box<span class="p">;</span> <span class="c">/* consider padding+border part of the width/height */</span>
        box<span class="o">-</span>sizing<span class="o">:</span> <span class="k">border</span><span class="o">-</span>box<span class="p">;</span>
    <span class="p">}</span>
<span class="o">&lt;/</span><span class="nt">style</span><span class="o">&gt;</span>
</pre></div><h4 id="ControlUsage">Control Usage</h4>
<p>
This custom Control can now be used like any UI5 Control:
</p>
<div class="code"><pre>var myControl <span class="o">=</span> <span class="k">new</span> my<span class="o">.</span><span class="na">Square</span><span class="o">({</span><span class="nl">text:</span><span class="s">"Hello"</span><span class="o">,</span> <span class="nl">size:</span> <span class="s">"100px"</span><span class="o">});</span>
myControl<span class="o">.</span><span class="na">placeAt</span><span class="o">(</span><span class="s">"content"</span><span class="o">);</span>
</pre></div><p>
<br />
</p>
<h3 id="ASimpleContainerControl">A Simple Container Control</h3>
<p>
A container Control that can hold arbitrary child Controls and renders them in a row, with a colored box around each child, looks like this:
</p>
<h4 id="ControlImplementation1">Control Implementation</h4>
<div class="code"><pre>  sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">Control</span><span class="o">.</span><span class="na">extend</span><span class="o">(</span><span class="s">"ColorBoxContainer"</span><span class="o">,</span> <span class="o">{</span> <span class="c1">// call the new Control type "ColorBoxContainer" 
</span>                                                    <span class="c1">// and let it inherit from sap.ui.core.Control
</span>      
      <span class="c1">// the Control API:
</span>      metadata <span class="o">:</span> <span class="o">{</span>
         properties <span class="o">:</span> <span class="o">{</span>            <span class="c1">// setter and getter are created behind the scenes, 
</span>                                   <span class="c1">// incl. data binding and type validation
</span>            <span class="s">"boxColor"</span> <span class="o">:</span> <span class="s">"string"</span>  <span class="c1">// the color to use for the frame around each child Control
</span>         <span class="o">},</span>
         <span class="nl">aggregations:</span> <span class="o">{</span>
            <span class="nl">content:</span> <span class="o">{</span><span class="nl">singularName:</span> <span class="s">"content"</span><span class="o">}</span> <span class="c1">// default type is "sap.ui.core.Control", multiple is "true"
</span>         <span class="o">}</span>
      <span class="o">},</span>
      
      <span class="c1">// the part creating the HTML:
</span>      renderer <span class="o">:</span> function<span class="o">(</span>oRm<span class="o">,</span> oControl<span class="o">)</span> <span class="o">{</span> <span class="c1">// static function, so use the given "oControl" instance 
</span>                                           <span class="c1">// instead of "this" in the renderer function
</span>          oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;div"</span><span class="o">);</span> 
          oRm<span class="o">.</span><span class="na">writeControlData</span><span class="o">(</span>oControl<span class="o">);</span>  <span class="c1">// writes the Control ID and enables event handling - important!
</span>          oRm<span class="o">.</span><span class="na">writeClasses</span><span class="o">();</span>              <span class="c1">// there is no class to write, but this enables 
</span>                                           <span class="c1">// support for ColorBoxContainer.addStyleClass(...)
</span>          oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>

          var aChildren <span class="o">=</span> oControl<span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
          <span class="k">for</span> <span class="o">(</span>var i <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> i <span class="o">&lt;</span> aChildren<span class="o">.</span><span class="na">length</span><span class="o">;</span> i<span class="o">++)</span> <span class="o">{</span> <span class="c1">// loop over all child Controls, 
</span>                                                       <span class="c1">// render the colored box around them
</span>              oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;div"</span><span class="o">);</span>
              oRm<span class="o">.</span><span class="na">addStyle</span><span class="o">(</span><span class="s">"display"</span><span class="o">,</span> <span class="s">"inline-block"</span><span class="o">);</span>
              oRm<span class="o">.</span><span class="na">addStyle</span><span class="o">(</span><span class="s">"border"</span><span class="o">,</span> <span class="s">"3px solid "</span> <span class="o">+</span> oControl<span class="o">.</span><span class="na">getBoxColor</span><span class="o">());</span> <span class="c1">// specify the border around the child
</span>              oRm<span class="o">.</span><span class="na">writeStyles</span><span class="o">();</span>
              oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>

              oRm<span class="o">.</span><span class="na">renderControl</span><span class="o">(</span>aChildren<span class="o">[</span>i<span class="o">]);</span>   <span class="c1">// render the child Control 
</span>                                                 <span class="c1">// (could even be a big Control tree, but you don't need to care)
</span>
              oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;/div&gt;"</span><span class="o">);</span> <span class="c1">// end of the box around the respective child
</span>          <span class="o">}</span>

          oRm<span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;/div&gt;"</span><span class="o">);</span> <span class="c1">// end of the complete Control
</span>      <span class="o">}</span>
  <span class="o">});</span>
</pre></div><p>
There is no additional CSS required, as the Control has no appearance on its own, but basically consists of its children and the boxes around them.
</p>
<h4 id="ControlUsage1">Control Usage</h4>
<p>
This strange container Control can now be used like any UI5 container:
</p>
<div class="code"><pre>  var btn <span class="o">=</span> <span class="k">new</span> sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">Button</span><span class="o">({</span><span class="nl">text:</span><span class="err">'</span>Hello World<span class="err">'</span><span class="o">});</span>
  var tf <span class="o">=</span> <span class="k">new</span> sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">TextField</span><span class="o">({</span><span class="nl">value:</span><span class="err">'</span>edit text here<span class="err">'</span><span class="o">});</span>
  
  var container <span class="o">=</span> <span class="k">new</span> ColorBoxContainer<span class="o">({</span>
      <span class="nl">boxColor:</span> <span class="s">"#ff7700"</span><span class="o">,</span>
      <span class="nl">content:</span><span class="o">[</span>
          btn<span class="o">,</span>
          tf
      <span class="o">]});</span>
  container<span class="o">.</span><span class="na">placeAt</span><span class="o">(</span><span class="err">'</span>content<span class="err">'</span><span class="o">);</span>
</pre></div><p>
<br />
</p>
<h2 id="ExamplesforExtendingExistingControls">Examples for Extending Existing Controls</h2>
<h3 id="ExtendingtheButtonwithanadditionalEvent">Extending the Button with an additional Event</h3>
<p>
Let's build a new Control, named "HoverButton" that is just like the normal Button, but fires a "hover" event in addition when the mouse enters its area.
</p>
<h4 id="ControlImplementation2">Control Implementation</h4>
<div class="code"><pre>  sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">Button</span><span class="o">.</span><span class="na">extend</span><span class="o">(</span><span class="s">"HoverButton"</span><span class="o">,</span> <span class="o">{</span> <span class="c1">// call the new Control type "HoverButton" 
</span>                                                <span class="c1">// and let it inherit from sap.ui.commons.Button
</span>      <span class="nl">metadata:</span> <span class="o">{</span>
          <span class="nl">events:</span> <span class="o">{</span>
              <span class="s">"hover"</span> <span class="o">:</span> <span class="o">{}</span>  <span class="c1">// this Button has also a "hover" event, in addition to "press" of the normal Button
</span>          <span class="o">}</span>
      <span class="o">},</span>
      
      <span class="c1">// the hover event handler:
</span>      onmouseover <span class="o">:</span> function<span class="o">(</span>evt<span class="o">)</span> <span class="o">{</span>   <span class="c1">// is called when the Button is hovered - no event registration required
</span>          <span class="k">this</span><span class="o">.</span><span class="na">fireHover</span><span class="o">();</span>
      <span class="o">},</span>
      
      <span class="nl">renderer:</span> <span class="o">{}</span> <span class="c1">// add nothing, just inherit the ButtonRenderer as is; 
</span>                   <span class="c1">// In this case (since the renderer is not changed) you can also specify this explicitly with:  renderer:"sap.ui.commons.ButtonRenderer"
</span>                   <span class="c1">// (means you reuse the ButtonRenderer instead of create a new renderer)
</span>  <span class="o">});</span>
</pre></div><p>
  
 
</p>
<h4 id="ControlUsage2">Control Usage</h4>
<p>
Use this ToggleButton in an application just like a regular Button - but you can now attach a handler to the "hover" event.
</p>
<div class="code"><pre>  var myControl <span class="o">=</span> <span class="k">new</span> HoverButton<span class="o">(</span><span class="s">"myBtn"</span><span class="o">,</span> <span class="o">{</span>
      <span class="nl">text:</span> <span class="s">"Hover Me"</span><span class="o">,</span>
      <span class="nl">hover:</span> function<span class="o">(</span>evt<span class="o">)</span> <span class="o">{</span>
          alert<span class="o">(</span><span class="s">"Button "</span> <span class="o">+</span> evt<span class="o">.</span><span class="na">getSource</span><span class="o">().</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">" was hovered."</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">});</span>
  myControl<span class="o">.</span><span class="na">placeAt</span><span class="o">(</span><span class="s">"content"</span><span class="o">);</span>
</pre></div><h3 id="ExtendingtheTextFieldRendering">Extending the TextField Rendering</h3>
<p>
Let's build a new Control type that inherits from TextField and has all its features, but changes the rendering to be very highlighted with yellow background.
</p>
<h4 id="ControlImplementation3">Control Implementation</h4>
<p>
All of the Control API and even the "render" method can be inherited as is. We only overwrite the renderInnerAttributes method of the TextFieldRenderer:
</p>
<div class="code"><pre>  sap<span class="o">.</span><span class="na">ui</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">TextField</span><span class="o">.</span><span class="na">extend</span><span class="o">(</span><span class="s">"HighlightField"</span><span class="o">,</span> <span class="o">{</span> <span class="c1">// call the new Control type "HighlightField" 
</span>                                                      <span class="c1">// and let it inherit from sap.ui.commons.TextField
</span>      
      <span class="nl">renderer:</span> <span class="o">{</span>
          <span class="c1">// note that NO render() function is given here! The TextField's render() function is used. 
</span>          <span class="c1">// But one function is overwritten:
</span>          
          renderInnerAttributes <span class="o">:</span> function<span class="o">(</span>oRm<span class="o">,</span> oTextField<span class="o">)</span> <span class="o">{</span>
              oRm<span class="o">.</span><span class="na">addStyle</span><span class="o">(</span><span class="err">'</span>background<span class="o">-</span>color<span class="err">'</span><span class="o">,</span> <span class="err">'#</span>ffff00<span class="err">'</span><span class="o">);</span>  <span class="c1">// this change could also be done with plain CSS!! 
</span>                                                            <span class="c1">// But you get the idea...
</span>          <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">});</span>
</pre></div><p>
  
</p>
<h4 id="ControlUsage3">Control Usage</h4>
<p>
Use this HighlightField in an application just like a regular TextField. It has all the normal features and behavior. But it has the modified rendering.
</p>
<div class="code"><pre>var myControl <span class="o">=</span> <span class="k">new</span> HighlightField<span class="o">({</span><span class="nl">value:</span><span class="s">"Highlighted editing"</span><span class="o">});</span>
myControl<span class="o">.</span><span class="na">placeAt</span><span class="o">(</span><span class="s">"content"</span><span class="o">);</span>
</pre></div>
        
        
      </div>
    </div>
    
  </body>
</html>